---
title: 万象归一
author: 凉香栾
date: 2025-05-12 19:02:10 +0800
categories:
  - 算法题解
tags:
  - 动态规划
description: 动态规划系列参考题解一
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath:
---


## 题目描述

大英雄Bat在一条笔直的小道上摆放了一排$n（n \le 600）$堆灵石，希望将它们最终合并成一堆。每次只能选相邻的$2$堆灵石合并成新的一堆，而且，新的一堆灵石数（即原来两堆灵石的数量和）可以给大英雄Bat提供下次渡劫使用的灵气值。

试编程求出将$n$堆灵石合并成一堆的最小可能总灵气值和最大可能总灵气值  

## 解题思路

无论以何种顺序合并，最终将从第`i`堆到第`j`堆的灵石合并成一大堆时，其最后一次合并必然是将某个点`k`（`i <= k < j`）分开的两堆——即`[i...k]`合并后的大堆与`[k+1...j]`合并后的大堆——进行合并。

这次最终合并产生的灵气值是固定的，等于从`i`到`j`所有灵石的总和，我们记为 `S(i, j)`。而总的灵气值，则等于 **合并`[i...k]`的灵气值** + **合并`[k+1...j]`的灵气值** + **最后一次合并产生的灵气值 `S(i, j)`**。

这个结构具有最优子结构性质：要想`[i...j]`区间的总灵气值最小（或最大），其子区间`[i...k]`和`[k+1...j]`的合并灵气值也必须是最小（或最大）的。我们需要找到一个合适的分割点`k`，使得上述总和达到最小或最大。

**状态转移方程：**

对于任意一个分割点`k`：
* 合并区间`[i, k]`的最小灵气值为 $dp_{min}[i][k]$。
* 合并区间`[k+1, j]`的最小灵气值为 $dp_{min}[k+1][j]$。
* 最后一次合并这两堆（即`[i,k]`和`[k+1,j]`）产生的灵气值为该区间所有灵石的和，即 $sum[j] - sum[i-1]$。

因此，通过分割点`k`合并区间`[i, j]`的总灵气值为：$dp_{min}[i][k] + dp_{min}[k+1][j] + (sum[j] - sum[i-1])$。

为了求得 $dp_{min}[i][j]$，我们需要遍历所有可能的分割点`k`，并取其中的最小值。这就得出了我们的状态转移方程：

* **最小灵气值递推式:**
	$$dp_{min}[i][j] = \min_{i \le k < j} \{ dp_{min}[i][k] + dp_{min}[k+1][j] \} + (sum[j] - sum[i-1])$$

* **最大灵气值递推式（同理）:**
    $$dp_{max}[i][j] = \max_{i \le k < j} \{ dp_{max}[i][k] + dp_{max}[k+1][j] \} + (sum[j] - sum[i-1])$$

**初始化（边界条件）**
* 当区间长度为1时，即`i == j`，只有一堆灵石，不需要合并，所以灵气值为0。
    $dp_{min}[i][i] = 0$
    $dp_{max}[i][i] = 0$
* 在计算 $dp_{min}[i][j]$ 之前，应将其初始化为一个极大值（如 `INT_MAX`）。
* 在计算 $dp_{max}[i][j]$ 之前，应将其初始化为一个极小值（如 `INT_MIN` 或 0）。

**注意计算顺序**

动态规划的计算应该保证在计算一个状态时，它所依赖的子问题状态已经被计算出来。在这里，计算长度为`len`的区间`[i, j]`时，需要用到所有长度小于`len`的子区间`[i, k]`和`[k+1, j]`的结果。因此，我们应该按照**区间长度从小到大**的顺序进行计算。

* 外层循环枚举区间长度 `len`，从 2 到 `n`。
* 内层循环枚举区间的起始点 `i`，从 1 到 `n-len+1`。
* 区间的结束点 `j` 可以由 `i` 和 `len` 算出：`j = i + len - 1`。
* 最内层循环枚举分割点 `k`，从 `i` 到 `j-1`。


## 附AC代码

```cpp
#include <iostream>
#include <algorithm>
#include <climits>
using namespace std;
int n,a,sum[605],dp_min[605][605],dp_max[605][605];

int main() {
    cin >> n;
    for(int i=1; i<=n;++i){
        cin >> a;
        sum[i]=sum[i-1]+a;
        dp_min[i][i] = 0;
        dp_max[i][i] = 0;
    }

    for(int len=2; len <= n;++len){
        for(int i=1; i+len-1<=n;++i){
            int j=i+len-1;
            dp_min[i][j]=INT_MAX;
            dp_max[i][j]=INT_MIN;
            for(int k=i; k < j; ++k){
                int cost = dp_min[i][k]+dp_min[k+1][j]+(sum[j]-sum[i-1]);
                dp_min[i][j] = min(dp_min[i][j], cost);
                cost = dp_max[i][k]+dp_max[k+1][j]+(sum[j]-sum[i-1]);
                dp_max[i][j] = max(dp_max[i][j], cost);
            }
        }
    }

    cout << dp_min[1][n] << "\n" << dp_max[1][n] << endl;

    return 0;
}

```