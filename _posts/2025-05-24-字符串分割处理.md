---
title: 字符串分割处理
author: 凉香栾
date: 2025-05-24 19:05:34 +0800
categories:
  - 算法题解
tags:
  - 动态规划
description: 动态规划系列参考题解六
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath:
---


## 题目描述

某个字符串处理语言提供了一个将字符串一分为二的基本操作。
由于该操作需要拷贝原来的字符串，因此对于长度为$n$的串，无论在其什么位置进行分割，都需要花费n个单位的时间。
现在假设我们要将一个字符串分割成多段，具体的分割次序会对总的运行时间产生影响 。
例如，如果要在位置3和位置10分割一个长度为20的串，首先在位置3进行分割产生的总代价为20+17=37 ，而首先在位置10进行分割产生的总代价为20+10=30  

> **输入：**  
> 第一行是两个整数：字符串长度$n$（不超过200000），分割位置的个数$m$（不超过1000）
> 第二行按递增顺序包含$m$个整数，表示$m$个分割位置（每个位置$X$的取值都满足$1 \le X \lt n$）  
> **输出：**  
> 最小可能总代价

## 解题思路

#### 问题分析

当我们要对一段木棍 `[i, j]` 进行所有内部切割时，我们可以选择其中任意一个切割点 `k` 作为**本次**的第一次切割。这次切割的代价是 `j - i`。切割后，问题被分解为两个完全独立的子问题：对 `[i, k]` 段进行切割和对 `[k, j]` 段进行切割。

总代价 = `(j - i)` + `(切割[i,k]的最小代价)` + `(切割[k,j]的最小代价)`。

为了方便处理边界，我们将木棍的两个端点0和 `n` 也看作是“切割点”。我们将这 `m+2` 个点（0, `m`个切割点, `n`）排序存入一个新数组，我们称之为 `cuts` 数组。
* `cuts[0] = 0`
* `cuts[1...m]` = 题目给定的 `m` 个切割位置
* `cuts[m+1] = n`

**状态定义：**
`dp[i][j]` 表示将 `cuts[i]` 到 `cuts[j]` 这一段木棍，按照其内部包含的所有切割点，完全切开所需的最小总代价。

我们的最终目标就是求解 `dp[0][m+1]`，即把从0到 `n` 的整根木棍完全切开的最小代价。由此得到状态转移方程：

$$dp_{i,j} = \min_{i < k < j} \{ dp_{i,k} + dp_{k,j} \} + (\text{cuts}_j - \text{cuts}_i)$$

初始条件为：$dp_{i, i+1} = 0$，即长度为1的段不用切割。


## 附AC代码

```cpp
#include <iostream>
#include <algorithm>
#include <climits>
using namespace std;

int n,m,dp[1010][1010],cuts[1010];

int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; i++)
        cin >> cuts[i];
    cuts[m+1] = n;

    for(int len = 2;len <= m+1;len++) {
        for(int i = 0;i+len <= m+1;i++) {
            int j = i+len;
            dp[i][j] = INT_MAX;
            for(int k = i + 1; k < j; k++)
                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]+(cuts[j]-cuts[i]));
        }
    }

    cout << dp[0][m+1] << endl;
    return 0;
}
```