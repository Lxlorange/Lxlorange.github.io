---
title: 带权的皇后
author: 凉香栾
date: 2025-06-16 23:23:42 +0800
categories:
  - 算法题解
tags:
  - 分支限界
description: 分支限界系列参考题解四
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath:
---

## 题目描述

在一个 `N x N` 的棋盘上，每个格子 `(i, j)` 都有一个非负整数权值。现在要向棋盘中放置 `N` 个皇后，要求任意两个皇后都不能处于同一行、同一列或同一条对角线上。

找到一种合法的放置方案，使得这 `N` 个皇后所在格子的权值之和最大，并输出这个最大值。

>**输入**：
>第一行为一个整数 `N`（`1 <= N <= 20`），代表棋盘的大小。
>接下来 `N` 行，每行 `N` 个整数，代表棋盘上对应位置的权值。
>**输出**：
>一个整数，表示权值之和的最大值。


## 解题思路

> 非常标准的分支限界题，但实测朴素回溯也能过（笑
{: .prompt-tip}

我们希望能找到一个“乐观”而“紧凑”的上界，当我们正在为第 `r` 行（从0开始计数）寻找位置时，此时已经确定了前 `r` 行皇后的位置和权值和 `sum`，需要估算剩下 `r` 到 `N-1` 行能贡献的最大权值。

这里可以暂时忽略列和对角线的约束，只考虑能在剩下的每一行中取得的最大收益，显然不会超过该行所有格子中的最大值。

在搜索开始前，我们可以先计算出每一行的最大权值，存入数组 `rowMax` 中。即 `rowMax[i] = max(a[i][0], a[i][1], ..., a[i][N-1])`。

为了在搜索中快速得到未来所有行的最大权值和，计算 `rowMax` 数组的**后缀和**，存入 `suffixMax` 数组。`suffixMax[i]` 表示从第 `i` 行到最后一行，各行最大权值的总和。
$$\text{suffixMax}[i] = \sum_{k=i}^{N-1} \text{rowMax}[k]$$
当我们搜索到第 `r` 行时，未来 (`r` 到 `N-1` 行) 的收益上限 `Ce` 就是 `suffixMax[r]`。在 `dfs(r, sum)` 函数的开头只要：    
$$\text{sum} + \text{suffixMax}[r] \le \text{best}$$
就可以剪枝了。


## 附AC代码

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int N,a[21][21],rowMax[21];
long long best,suffixMax[22];
bool vis_col[20],vis_d1[40],vis_d2[40];

void dfs(int r, long long sum) {
	if (sum + suffixMax[r] <= best) return; //是的，反正我当时没有这句好像也过了
    if (r == N) {
        best = max(best, sum);
        return;
    }
    
    for (int c = 0; c < N; ++c) {
        if (vis_col[c]) continue;
        int d1 = r + c, d2 = r - c + N;
        if (vis_d1[d1] || vis_d2[d2]) continue;

        vis_col[c] = vis_d1[d1] = vis_d2[d2] = true;
        dfs(r+1, sum + a[r][c]);
        vis_col[c] = vis_d1[d1] = vis_d2[d2] = false;
    }
}


int main(){
    scanf("%d", &N);
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            scanf("%d", &a[i][j]);

    for (int i = 0; i < N; i++) {
        int mx = 0;
        for (int j = 0; j < N; j++)
            mx = max(mx, a[i][j]);
        rowMax[i] = mx;
    }
    suffixMax[N] = 0;
    for (int i = N-1; i >= 0; i--)
        suffixMax[i] = suffixMax[i+1] + rowMax[i];

    best = 0;
    dfs(0, 0);
    printf("%lld\n", best);
    return 0;
}
```