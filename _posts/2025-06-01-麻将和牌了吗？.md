---
title: 麻将和牌了吗？
author: 凉香栾
date: 2025-06-01 10:57:48 +0800
categories:
  - 算法题解
tags:
  - 回溯
description: 回溯系列参考题解一
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath:
---


## 题目描述

麻将是中国的一种传统棋牌游戏，2017年4月，国际智力运动联盟宣布，麻将正式成为第六个世界智力运动项目。

本题所使用的麻将牌包括三大类：
* **筒子牌**: “一筒”至“九筒”，每种4张。
* **索子牌**: “一索”至“九索”，每种4张。
* **万子牌**: “一万”至“九万”，每种4张。
* **字牌**:
    * 风牌：“东风”、“南风”、“西风”、“北风”，每种4张。
    * 箭牌：“中”、“发”、“白”，每种4张。

为了便于程序处理，我们将不同的牌面与数值进行如下对应：

| 牌面  | 对应数值 | 牌面  | 对应数值 | 牌面  | 对应数值 | 牌面  | 对应数值 |
| :-- | :--- | :-- | :--- | :-- | :--- | :-- | :--- |
| 东风  | 1    | 一筒  | 11   | 一索  | 21   | 一万  | 31   |
| 南风  | 2    | 二筒  | 12   | 二索  | 22   | 二万  | 32   |
| 西风  | 3    | 三筒  | 13   | 三索  | 23   | 三万  | 33   |
| 北风  | 4    | 四筒  | 14   | 四索  | 24   | 四万  | 34   |
| 中   | 5    | 五筒  | 15   | 五索  | 25   | 五万  | 35   |
| 发   | 6    | 六筒  | 16   | 六索  | 26   | 六万  | 36   |
| 白   | 7    | 七筒  | 17   | 七索  | 27   | 七万  | 37   |
|     |      | 八筒  | 18   | 八索  | 28   | 八万  | 38   |
|     |      | 九筒  | 19   | 九索  | 29   | 九万  | 39   |

本题将给你14张牌，请你判断这14张牌是否构成以下两种基本和牌局面之一。

1.  **类型一：基本和牌 (m\*AAA + n\*ABC + DD)**
    由4组“刻子”（AAA，三张相同的牌）或“顺子”（ABC，三张同花色序数相连的牌）以及1组“将牌”（DD，两张相同的牌）组成。 
2.  **类型二：七对子 (7\*AA)**
    由7组两张相同的牌组成.

> **输入：**
> 一行，包含14个整数，代表14张牌的对应数值。
> **输出：**
> 第一行：如果构成和牌，输出"YES"，否则输出"NO"。
> 第二行：如果和牌，根据和牌类型输出"1"或"2"；如果不和牌，输出"0"。
> **优先规则：**
> 如果一手牌同时满足类型一和类型二，优先判定为类型二。

## 解题思路

按照题目要求，先检查手牌是否满足“七对子”的条件。如果满足，则问题解决，手牌为类型二和牌。如果不满足，再继续检查手牌是否满足“基本和牌”的条件。若满足，则为类型一和牌。若仍不满足，则该手牌不能和牌。

####  “七对子” 的判定方法
比较简单：
1.  首先，统计14张手牌中每一种牌（1-39）的出现次数。
2.  遍历每种牌的计数。若发现任意一种牌的计数为奇数，则判定失败。
3.  若所有牌的计数均为偶数，则计算总对子数（$\sum \frac{\text{每种牌的数量}}{2}$）。若总对子数等于7，则判定成功，为七对子；否则失败。

#### “基本和牌”的判定方法

“基本和牌”的结构是 `4组 + 1对`。这一结构的核心是，除去作为“将牌”的一对牌之外，其余的12张牌必须能被完美地划分成4个“组”。一个“组”可以是“刻子”（AAA）或“顺子”（ABC）。

由于我们事先不知道哪两张牌是“将牌”，所以需要进行尝试。

**判定算法**：
1.  遍历手牌中所有数量大于等于2的牌，轮流将其作为“将牌”的候选。
2.  对于每一个候选的“将牌”，我们先从手牌中“移除”这两张牌。
3.  然后，对剩下的12张牌调用一个子程序，判断这12张牌能否被成功划分为4个组。
4.  如果在所有候选“将牌”的尝试中，有任意一次使得剩下的12张牌可以成功划分，那么这手牌就满足“基本和牌”的条件。若所有尝试都失败，则判定失败。

这个方法的关键，在于如何实现第三步的子程序。即给定12张牌，判断它们能否凑成4个组（刻子或顺子）。这是一个典型的搜索问题，使用**递归回溯**（或深度优先搜索）是自然的选择。
设计递归函数`check()`：
* **递归的出口**：
    如果“剩余的牌”数量为0，说明所有牌都已成功组合成组，返回 `true`。
* **递归递进**：
    1.  从“剩余的牌”中，找到数值最小的一张牌，记为 `m`。我们必须为这张牌找到一个合法的组，否则这手牌就不可能成功。
    2.  **尝试凑成“刻子” (AAA)**：检查牌 `m` 的数量是否大于等于3。
        * 如果是，则从手中移除3张 `m`，然后对剩下的牌递归调用 `check()`。
        * 如果递归调用返回 `true`，说明找到了一条成功路径，立刻向上返回 `true`。
        * （如果返回`false`，说明此路不通，我们需要在逻辑上“撤销”这次操作，即回溯，去尝试下一种可能）。
    3.  **尝试凑成“顺子” (ABC)**：如果凑“刻子”不成功，或者牌 `m` 的数量不足3，我们接着尝试凑“顺子”。
        * 这要求 `m` 必须是序数牌（筒、索、万），且不能是8或9。
        * 检查手中是否同时存在 `m`, `m+1`, `m+2` 这三张牌。
        * 如果是，则从手中移除这三张牌，然后对剩下的牌递归调用 `check()`。
        * 如果递归调用返回 `true`，则向上返回 `true`。
    4.  **失败**：如果对牌 `m` 尝试了以上所有可能的组合方式，都无法最终使所有牌凑成组，那么说明从 `m` 开始的这条路是死路，函数返回 `false`。

## 附AC代码

```cpp
#include <iostream>
using namespace std;
int counts[40],pairnum;

bool istype2(){
    for (int i = 1; i <= 39; ++i) {
        if (counts[i]%2)
            return false;
        pairnum += counts[i] / 2;
    }
    return pairnum == 7;
}

bool check(){
    int m = -1;
    for (int i = 1; i <= 39; ++i) {
        if (counts[i] > 0) {
            m = i;
            break;
        }
    }
    if (m == -1)
        return true;
    
    if (counts[m] >= 3) {
        counts[m] -= 3;
        bool success = check();
        counts[m] += 3;
        if (success)
            return true;
    }

    if (m > 10 && (m % 10) <= 7) {
        if (counts[m + 1] > 0 && counts[m + 2] > 0) {
            counts[m]--;
            counts[m + 1]--;
            counts[m + 2]--;
            bool success = check();
            counts[m]++;
            counts[m + 1]++;
            counts[m + 2]++;
            if (success)
                return true;
        }
    }

    return false;
}
int main(){
    for (int i = 0; i < 14; ++i) {
        int tile;
        cin >> tile;
        counts[tile]++;
    }

    if (istype2()) {
        cout << "YES\n2" << endl;
        return 0;
    }

    for (int i = 1; i <= 39; ++i) {
        if (counts[i] >= 2) {
            counts[i] -= 2;
            if (check()) {
                cout << "YES\n1" << endl;
                return 0;
            }
            counts[i] += 2;
        }
    }

    cout << "NO\n0" << endl;
    return 0;
}

```