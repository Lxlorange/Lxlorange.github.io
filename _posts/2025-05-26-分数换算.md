---
title: 分数换算
author: 凉香栾
date: 2025-05-26 19:04:10 +0800
categories:
  - 算法题解
tags:
  - 动态规划
description: 动态规划系列参考题解五
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath: /assets/img/分数换算/
---


## 题目描述

**有时候需要把课程的百分制成绩换算成若干成绩段。**  

假设学生人数很多，且预知了每个成绩段的学生数，但是不知道每位学生各自属于哪个成绩段。

苗苗的兔宠白白接到了这个任务：

- 设计一棵判定树来确定每个学生的百分制成绩换算后应属于哪一个成绩段
- 判定树的分枝点表示一次比较
- 叶子顶点表示具体的分数段
- 希望获知将所有学生的百分制成绩都换算成成绩段的过程中的最少总比较次数和最多总比较次数

例如，假设某考试成绩为5段制，各段的人数如下表所示:

| 百分制成绩    | 0-59 | 60-69 | 70-79 | 80-89 | 90-100 |
| -------- | ---- | ----- | ----- | ----- | ------ |
| 五段制成绩    | 不及格  | 及格    | 中等    | 良好    | 优秀     |
| 每个分数段的人数 | 500  | 1500  | 4000  | 3000  | 1000   |

![共需进行 31 500 次比较](scoreTree1.png)

共需进行 31 500 次比较

![共需进行 22 000 次比较](scoreTree2.png)

共需进行 22 000 次比较

（图引自 严蔚敏, 吴伟民. 数据结构(C语言版)\[M\]. 清华大学出版社, 2007. “图6.23”）

> **输入：**  
> 分数段数（不超过600）  
> 各分数段的人数 （每个值都不超过1000）  
> **输出：**
> 最少总比较次数和最多总比较次数

## 解题思路

经典的OBST变种。题意是设计一棵判定树，对学生的百分制成绩进行分段，目标是使区分所有学生的总比较次数最少或最多。

对于树中的任意一个**内部节点**（一次比较），所有最终落入其子树中的学生都必须经过这次比较。因此，该内部节点贡献的比较次数 = 其子树中所有叶子节点的人数总和。

这个问题就转化成了：如何组织比较顺序（即如何构建这棵判定树），使得所有内部节点贡献的代价之和最小或最大。

#### 状态定义

  - `dp_min[i][j]`: 将第 `i` 个到第 `j` 个成绩段完全区分开（即构建这些段对应的最优判定子树）所需的**最少**总比较次数。
  - `dp_max[i][j]`: 将第 `i` 个到第 `j` 个成绩段完全区分开所需的**最多**总比较次数。
  - `sum[i]`: 前 `i` 个分数段的人数前缀和，用于快速计算任意区间的人数总和。

#### 状态转移方程

我们考虑构建区分第 `i` 到第 `j` 段的判定树。这棵树的根节点必然是一次比较，它将 `i..j` 这个区间分裂成两部分：`i..k` 和 `k+1..j`（其中 `i <= k < j`）。

  - 这次根节点比较的代价，等于当前区间 `i..j` 内的总人数，即 `sum[j] - sum[i-1]`。
  - 之后，问题分解为两个独立的子问题：构建 `i..k` 的最优子树和 `k+1..j` 的最优子树。

为了得到 `dp_min[i][j]`，我们需要遍历所有可能的分裂点 `k`，选择使总代价最小的那个。

  - **最小总比较次数**:
  
$$dp_{min}[i][j] = (\text{sum}_j - \text{sum}_{i-1}) + \min_{i \le k < j} \{ dp_{min}[i][k] + dp_{min}[k+1][j] \}$$

  - **最大总比较次数**:
  
$$dp_{max}[i][j] = (\text{sum}_j - \text{sum}_{i-1}) + \max_{i \le k < j} \{ dp_{max}[i][k] + dp_{max}[k+1][j] \}$$

初始状态 `dp_min[i][i] = 0`, `dp_max[i][i] = 0`，即当区间只包含一个成绩段时，无需任何比较来区分它，所以代价为0。

我们需要求解的是区分所有 `n` 个成绩段（即区间 `1..n`）的最小和最大代价。
最小总代价: `dp_min[1][n]`，最大总代价: `dp_max[1][n]`

## 附AC代码

```cpp
#include <iostream>
#include <algorithm>
#include <climits>

using namespace std;

#define MAXN 605

int n;
long long f[MAXN];
long long sum[MAXN];
long long dp_min[MAXN][MAXN];
long long dp_max[MAXN][MAXN];

int main() {
    cin >> n;

    sum[0] = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> f[i];
        sum[i] = sum[i - 1] + f[i];
        dp_min[i][i] = 0;
        dp_max[i][i] = 0;
    }

    for (int len = 2; len <= n; ++len) {
        for (int i = 1; i + len - 1 <= n; ++i) {
            int j = i + len - 1;
            long long current_sum = sum[j] - sum[i - 1];
            dp_min[i][j] = LLONG_MAX;
            dp_max[i][j] = 0;
            for (int k = i; k < j; ++k) {
                long long min_cost = dp_min[i][k] + dp_min[k + 1][j] + current_sum;
                dp_min[i][j] = min(dp_min[i][j], min_cost);
                long long max_cost = dp_max[i][k] + dp_max[k + 1][j] + current_sum;
                dp_max[i][j] = max(dp_max[i][j], max_cost);
            }
        }
    }

    cout << dp_min[1][n] << endl;
    cout << dp_max[1][n] << endl;
    return 0;
}
```