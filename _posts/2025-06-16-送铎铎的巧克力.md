---
title: 送铎铎的巧克力
author: 凉香栾
date: 2025-06-16 11:35:23 +0800
categories:
  - 算法题解
tags:
  - 分支限界
description: 分支限界系列参考题解一
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath:
---
## 题目描述

白白需要将一个长方形的礼物盒用正方形的巧克力完全填满。可供使用的巧克力是边长为 $1\times1, 2\times2, \cdots,25\times25$ 的正方形。

由于每块巧克力都需要独立的昂贵锡纸包装，白白希望在**完全填满**盒子的情况下，使用的巧克力**总块数达到最少**。

> **输入**
> 一行，两个正整数 `n` 和 `m`，代表礼物盒子的长和宽（本题中均不超过30）。 
> **输出**
> 一个整数，表示填满盒子所需的最少正方形巧克力块数。

## 解题思路

本题使用很朴素的剪枝就能通过：

1. 为了保证搜索的系统性和不重复，我们每次都选择**最左上角**的那个未被覆盖的格子 `(x, y)`。这个格子是当前必须处理的，任何合法的填充方案都必须用某块巧克力覆盖到它。
2. 假设我们剩下的所有未覆盖区域，都能够用最大号的巧克力（例如25x25）来完美填充。这显然是最乐观的情况，因为它使用的巧克力单块面积最大，从而总数量最少：
$$\text{count} + \lceil \frac{\text{remainArea}}{S_{max}} \rceil \ge \text{ans}$$
`count`为当前已用块数，`remainArea`为剩余区域面积，`Smax`取`25*25`。

## 附AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, ans = 1e9, remainArea;
bool g[35][35];

bool check(int x, int y, int sz) {
    if (x + sz > n || y + sz > m) return 0;
    for (int i = x; i < x + sz; ++i)
        for (int j = y; j < y + sz; ++j)
            if (g[i][j]) return 0;
    return 1;
}

void setChoco(int x, int y, int sz, bool val) {
    for (int i = x; i < x + sz; ++i)
        for (int j = y; j < y + sz; ++j)
            g[i][j] = val;
    remainArea += val ? -sz * sz : sz * sz;
}

void dfs(int cnt) {
    if (cnt >= ans) return;

    int minNeed = (remainArea + 625 - 1) / 625;
    if (cnt + minNeed >= ans) return;

    int x = -1, y;
    for (int i = 0; i < n && x == -1; ++i)
        for (int j = 0; j < m; ++j)
            if (!g[i][j]) { x = i; y = j; break; }

    if (x == -1) {
        ans = cnt;
        return;
    }

    int maxSz = min(n - x, m - y);
    for (int sz = maxSz; sz >= 1; --sz)
        if (check(x, y, sz)) {
            setChoco(x, y, sz, 1);
            dfs(cnt + 1);
            setChoco(x, y, sz, 0);
        }
}

int main() {
    scanf("%d%d", &n, &m);
    remainArea = n * m;
    dfs(0);
    printf("%d\n", ans);
    return 0;
}

```
