---
title: 尽可能公平的拔河游戏
author: 凉香栾
date: 2025-05-22 10:09:23 +0800
categories:
  - 算法题解
tags:
  - 动态规划
description: 动态规划系列参考题解二
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath:
---
## 题目描述

尽可能公平的拔河游戏 某科研团队共有 $n$ 人，体重分别是 $w_{1}, w_{2}, \dots , w_{n}$（都是正整数）。  

为增进成员感情，该团队决定组织一场友谊拔河赛。  

考虑到其中或有“横推八马倒，倒曳九牛回”的大力士，因此这场友谊拔河赛不要求双方人数相当，而是希望两边的总体重差达到最小。  


> **输入：**
> 第一行 `n` ，不超过$20001$
> 之后是$n$个人的体重（都是整数，且所有人体重和不超过$20000$）
> 
> **输出：**
> 非增序输出两个队伍的总体重，以一个空格分隔

## 解题思路


好的，我们来详细分析这道题的解题思路。

---

## 解题思路

假设所有人的总体重为 $S$。我们把所有人分成A、B两队，设A队的体重和为 $S_A$，B队的体重和为 $S_B$，则需要最小化 $\|S_A−S_B\| = \|2S_A−S\|$，也就是让 $S_A$ 尽可能地接近 $\frac{S}{2}$。

因此，这个问题就转化成了：
> 从所有$n$个人中，选取一部分人组成A队，使得A队的总重量 $S_A$ 尽可能地接近（但不能超过）$\frac{S}{2}$，并求出这个最接近的值。


### 方法一：0/1背包问题模型

把这样一个最优化问题看成0/1背包问题是相当王道的解法：

- **背包容量 (W):** 所有人总重量的一半，即 `target = sum / 2`。    
- **物品 (Items):** `n` 个人。
- **物品的重量 (weight):** 每个人的体重 $w_i$。
- **物品的价值 (value):** 为了让凑出的总重量尽可能大（接近`target`），我们认为每个物品的“价值”就等于它的“重量”。即 $v_i$=$w_i$。

问题又变成了：我们有一个容量为 `target` 的背包，和 `n` 个物品。第 `i` 个物品的重量和价值都是 $w_i$。我们往背包里装东西，每个物品只能选一次（0/1背包），问能得到的最大总价值是多少？

很容易能列出状态转移方程：
$$
dp[j]=max(dp[j],dp[j−w]+w)
$$
这里给出核心代码：

```cpp
int target = sum / 2;
vector<int> dp(target + 1, 0);

for (int i = 0; i < n; ++i) {
	for (int j = target; j >= w[i]; --j) {
		dp[j] = max(dp[j], dp[j - w[i]] + w[i]);
	}
}

int team1_weight = dp[target];
int team2_weight = sum - team1_weight;
```



### 方法二：凑值法+状态压缩

既然目标是凑成$sum/2$，我想知道输入的所有重量一共都能凑出哪些结果，然后选择这些结果中最接近中值的那个即可。

我们定义一个一维布尔数组 `dp`，`dp[j]`为 `true` 表示可以从已有的人中选出一部分，使他们的总体重**恰好**等于 `j`，`false` 则表示无法凑出。`dp[0] = true`。

当我们考虑一个体重为 `wi` 的新人时，我们需要更新 `dp` 数组。对于任意一个重量 `j`，要使其变为 `true`，有两种可能：

1.  在考虑新人 `wi` 之前，`dp[j]` 就已经是 `true` 了。
2.  在考虑新人 `wi` 之前，`dp[j-wi]` 是 `true`（选中这个新人，那么之前就需要凑出 `j-wi` 的重量）。

因此，状态转移可以表示为：
$$
dp[j] = dp[j] \vee dp[j - wi]
$$
核心代码如下：
```cpp
int target = sum/2;
vector<bool> dp(target + 1, false);
dp[0] = true;

for (int current_weight : w) {
    for (int j = target; j >= current_weight; --j) {
        if (dp[j - current_weight]) {
            dp[j] = true;
        }
    }
}
int team1_weight = 0;
for (int j = target; j >= 0; --j) {
    if (dp[j]) {
        // 从 target 向下找，第一个为 true 的就是最接近 sum/2 的可凑出重量
        team1_weight = j;
        break;
    }
}

int team2_weight = sum - team1_weight;
```

然后这个答案就超时了。总复杂度为$\Theta(nS)$，当总重$S$很大时，很容易被卡。

于是尝试使用 `bitset` 来记录状态以降低复杂度。

`dp << wi` 这个操作会将 `dp` 中所有的位向左移动 `wi` 位。如果原来 `dp[j]` 是 `1`，那么移动后新 `bitset` 的第 `j + wi` 位就变成了`1`。这恰好代表了所有“在原来基础上加上`wi`”能得到的新重量。

所以，`dp |= dp << wi;` 这行代码的含义是：
- `dp << wi`：计算出如果把体重为 `wi` 的人加入到**之前所有可能**的队伍组合中，能够形成的一系列新的总重量。
- `|=`：将这些新的可达总重量，与旧的可达总重量合并。

这样，我们把时间复杂度降到了 $O(n \cdot \frac{S}{w_{size}})$，其中 `w_size` 是机器字长（通常是32或64），在这个题目条件内（不太大的$S$），恰恰可以通过。

## 附AC代码

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <bitset>
using namespace std;

int n,w[20010],sum,m;
bitset<20010> dp;

int main(){
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> w[i];
        sum += w[i];
    }
    m = sum/2;

    dp[0] = 1;
    for (int wi : w) { dp |= dp << wi; }
    int flag=0;
    for (int j = m; j >= 0; --j) { if (dp[j]) { flag = j; break; } }
    
    cout << sum-flag << " " << flag << endl;
    
    return 0;
}
```