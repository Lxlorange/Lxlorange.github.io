---
title: 递归中使用全局变量的后果
date: 2025-04-02 21:15:47 +0800
categories: [算法, C++]
tags: [算法, C++, Debug]
description: 在递归中使用了全局变量这一蠢事带来的思考
---

# 递归中使用全局变量的后果

在用**分治法**做经典的**股票买卖**问题时，遇到一些数据点过不了，一开始还以为是分块方式有问题，后来发现很蠢地用了全局变量。

```cpp
//错误版本
int arr[50010],n,x1,x2,x3,lm,rm,ans;
int merge(int l, int r) {  
    if(l>=r) return 0;  
    int mid = (l+r)/2;  
    x1 = merge(l, mid-1);  //x1和x2应声明为局部变量，其他没关系但最好也改一下
    x2 = merge(mid+1, r);  
    lm = arr[mid], rm = arr[mid];  
    for(int i=mid; i>=l; i--)  
        lm = min(arr[i], lm);  
    for(int i=mid; i<=r; i++)  
        rm = max(rm, arr[i]);  
    x3 = rm - lm;  
    return max(max(x1, x2), x3);  
}
```


~~这算是写少了才de不出来的低级bug，~~顺便分析一下发生条件吧。

**递归的调用可以理解成是树形的**，当递归左子树（`merge(l, mid-1)`）计算出 `x1` 后，递归右子树（`merge(mid+1, r)`）会仍然使用这个被算出来的 `x1(>0)` 进行计算。由于递归终点返回`0`，所以`x2`在最左子树的右孩子时就已经是错误的值了。

而那些通过的案例，应该是以下可能之一：
- **最大差值仅出现在中间合并区间**
	- 如果正确结果由当前层的 `x3`（中间区间的 `rm-lm`）直接决定，而 `x1` 和 `x2` 的值无关紧要（即使被覆盖也不影响 `max(x3)`），此时程序可能输出正确结果。
- **递归深度较浅，未发生覆盖现象**


