---
title: 动态规划
author: 凉香栾
date: 2025-07-30 02:18:27 +0800
categories: 
tags: 
description: 
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath: /assets/img/动态规划/
image:
  path: cover.jpg
  lqip: 
  alt: 动态规划
---


_动态规划_（Dynamic Programming，简称DP）由美国数学家Richard Bellman在20世纪50年代提出，它的核心思想是将一个复杂的问题分解成若干个子问题并分别求解、记录答案、通过子问题答案快速求得源问题答案，因此动态规划常常适用于有重叠子问题和最优子结构性质的问题。

> Dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems.

Dynamic Programming中虽然有编程（Programming）这个词，但DP的核心并不是编程方法，而是一种**自底而上的填表法**。在解决许多看似复杂的算法问题时，我们常常陷入递归的重复计算泥潭，效率低下、难以优化。而动态规划以其独特的“先解决小问题、再构建大问题”的策略，提供了一种高效、系统的思维方式。无论是求解最长子序列、最短路径，还是优化背包问题，动态规划的核心步骤几乎都遵循同一个模式：**定义状态、找出状态转移方程、设计一个表格（数组）按顺序逐步填满，最终得到目标答案**。

不同问题情景总是对应不同的状态转移方程，但常见情景是数量有限的，我们可以用有限的思路来构造这些常见情景的转移方程。

## 找零问题

在贪婪策略一章中，我们通过举反例的方法已经证明过，对于有些面额的找零问题，贪婪会陷入局部最优而得到错误答案。好在DP提供了更通用的方法。

为了求得凑出 $n$ 元所需的最少硬币数，我们可以思考“构成最终总额的最后一枚硬币是哪一个？” 

对于面值 `{1, 5, 7, 10}` 和目标19元的情况，这最后一枚硬币只可能是这四种之一：

  * 如果最后一枚是1元，那么在这之前我们必须已经凑好了18元。 
  * 如果最后一枚是5元，那么之前我们必须凑好了14元。 
  * 如果最后一枚是7元，那么之前我们必须凑好了12元。 
  * 如果最后一枚是10元，那么之前我们必须凑好了9元。 

显然，要想让总硬币数最少，我们在凑之前的金额时，也必须使用最少的硬币。设 $C(n)$ 为凑出金额 $n$ 所需的最少硬币数，问题就转化成了：

$$
C(19) = 1 + \min \big( C(18), C(14), C(12), C(9) \big)
$$

设 $C(n)$ 为凑出金额 $n$ 的最少硬币数，$d_{1}, d_{2}, \cdots, d_{m}$ 为硬币面值，则：
$$C(n) = 1 + \min_{1\le k \le m \cap n \ge d_{k}} \{ C(n - d_k) \}$$
编程求解$C(19)$，很容易想到递归地调用函数，核心伪代码如下：
```txt
Find(n)
if n=0 then return 0
if n<0 then return INFINITY
return min{
    Find(n-1)+1,
    Find(n-5)+1,
    Find(n-7)+1,
    Find(n-10)+1,
    }
```
但显然这个方法效率低、开销大，因为会产生重复计算，例如`Find(9)`就被调用了好几次。

而DP通过从$1$开始向上求解，使用数组把求过的值存储起来，可以有效地提高效率：
```txt
Find(n)
Find[0] is 0         // 凑出0元需要0个硬币
Find[i] is INFINITY for all i < 0  // 事实上，对Find[-1] ~ Find[-10] 赋初值 INFINITY 即可

for i = 1 to n:
    Find[i] is min{
        Find[i-1] + 1,
        Find[i-5] + 1,
        Find[i-7] + 1,
        Find[i-10] + 1,
    }
```

因为币种数量通常是不太大的常数，所以这个算法的时间复杂度总是`O(n)`。

从这个例题可以看出，DP可用于解决各种**离散最优化问题**。在这些问题中，可能有多个解，每个解都有一个值，我们希望找到一个具有最佳（最小或最大）值的解。我们称这种解为该问题的最佳解之一（因为可能有多个最优解都达到了最优值）。

## 最长单调递增子序列

### 子序列长度

LIS (Longest Increasing Subsequence)，这个情景希望从一个数值序列中，找到一个尽可能长的子序列，要求该子序列中的所有元素都是严格单调递增的。 

> **子序列**
> 和子串不同，序列$S$的子序列，是通过从$S$中删除零个或多个元素，并保持其余元素的原有相对顺序得到的。 

令$S[1]S[2]\dots S[n]$表示输入序列，则定义$L(i)$为以 $S[i]$ **结尾**的最长单调递增子序列的长度。 

> 若定义$L(i)$为序列 $S[1]S[2]\dots S[i]$ 的最长单调递增子序列的长度，如果$L(i)$对应的序列以数值$a$结尾且$a \ge s[i+1]$，那么我们得到的结果一定是错误的。
> 在这个问题中，**一个序列能否被扩展，唯一取决于它的结尾元素**。而一个好的状态定义不应该关心这些之前的状态是如何得到的，也不需要未来的信息。我们称这种状态定义是**无后效性**的。如果一个状态定义破坏了无后效性，它就会在状态转移过程中制造错误的结果。
{: .prompt-danger }

要计算 $L(i)$，即以 $S[i]$ 结尾的LIS长度，我们需要思考 $S[i]$ 是如何加入一个子序列的。$S[i]$ 只能接在它之前的某个元素 $S[j]$ ($j < i$) 后面。

这个接续必须满足单调递增的条件，即 $S[j] < S[i]$。如果满足条件，$S[i]$ 就可以接在以 $S[j]$ 结尾的最长递增子序列后面，形成一个更长的、以 $S[i]$ 结尾的子序列，其长度为 $L(j) + 1$。

由于可能存在多个这样的 $S[j]$，我们自然要选择那个能让新序列最长的，也就是 $L(j)$ 最大的那个。因此，我们得到状态转移方程：

$$
L(i) =
\begin{cases}
1 + \displaystyle\max_{\substack{0 \leq j < i \\ S[j] < S[i]}} L(j), & \text{如果 $j$ 存在}, \\[1.2em]
1, & \text{other}.
\end{cases}
$$

* 这个方程表示，$L(i)$ 的值是所有满足条件的 $L(j)$ 的最大值加1。
* $\max$ 函数中包含 ${0}$ 是为了处理一种边界情况：如果找不到任何一个 $S[j]$ 小于$S[i]$，说明 $S[i]$ 只能自成一派，形成一个长度为$1$的递增子序列。

由于LIS不一定以最后一个元素结尾，它可能以序列中的任何一个元素结尾。根据我们的状态定义，整个序列的LIS长度就是所有 $L(i)$ 值中的最大值。
$$len(LIS) = \max(dp[1], dp[2], \dots, dp[n])$$
### 还原子序列

$L(i)$ 只告诉我们长度。如果想知道具体的子序列是什么，我们需要在计算过程中额外记录一些信息。我们可以引入一个**前驱函数** $P(i)$，表示构成以 $S[i]$ 结尾的LIS时，$S[i]$ 前面的那个元素在原序列中的索引。

在计算 $L(i)$ 时，如果我们发现 $L(i)$ 的值是由 $L(j) + 1$ 更新得到的，我们就同时记录 $P(i) = j$。

计算完所有 $L(i)$ 和 $P(i)$ 值后，我们可以：

1. 找到 $L(i)$ 中最大值的索引 $k$。$S[k]$ 就是某一个LIS的最后一个元素。
2. 通过 $P(i)$ 进行**回溯**：从 $k$ 开始，下一个前驱是 $P(k)$，再下一个是 $P(P(k))$，依此类推，直到找到序列的开端。
3. 将回溯得到的索引序列反转，即可得到一个最长单调递增子序列。

时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。 


## 最大子段和

> **问题描述**：给定一个由 $n$ 个整数（可能为负数）组成的序列 $a_1, a_2, \dots, a_n$，找出该序列的一个**连续子段** $a_i, \dots, a_j$ (其中 $1 \le i \le j \le n$)，使得这个子段中所有元素的和最大。  
>
> 为了处理特殊情况，规定：**如果所有子段的和都是负数，则最大子段和定义为 0**（相当于选择一个空子段）。  

如果我们定义 $F(i)$ 为“所有以元素 $a_i$ 结尾的连续子段的最大和”，那么状态就和序列的具体位置绑定起来。  注意这个定义的强制性——子段**必须**以 $a_i$ 作为其最后一个元素。  

当我们计算 $F(i)$ 时，可以有两种情况： 
  * **子段只包含 $a_i$ 本身**。这种情况发生在 $F(i-1)$ 为负数时。如果把它加上只会让和更小，那么直接从 $a_i$ 开始新的子段更优。  
  * **子段由“以 $a_{i-1}$ 结尾的最优子段”接上 $a_i$ 构成**。这种情况发生在 $F(i-1)$ 为正时，此时继续延伸可以得到更大的和。  

因此我们得到状态转移方程：
$$
F(i) = a_i + \max(F(i-1), 0)
$$
这可以进一步写成更简洁的形式：
$$
F(i) = \max(a_i, a_i + F(i-1))
$$
这个方程的含义是：以 $a_i$ 结尾的最大子段和，要么是 $a_i$ 自己（如果 $F(i-1)$ 为负），要么是 $a_i + F(i-1)$。  

由于最大子段和可以以任意元素结尾，所以全局最优解为：
$$
S = \max(0, \max_{1 \le i \le n} F(i))
$$

其中与 $0$ 比较，是为了处理所有子段和都为负的情况。  

观察状态转移方程 $F(i) = \max(a_i, a_i + F(i-1))$，我们发现计算 $F(i)$ 只依赖于 $F(i-1)$。因此，我们根本不需要大小为 $n$ 的数组来保存全部状态，而只需两个变量：
  * 一个变量表示当前 $F(i)$，即“到当前位置为止的最大子段和”；  
  * 另一个变量表示全局最大值，即 $\max\{F(1), F(2), \dots, F(i)\}$。  

这就是著名的 **Kadane算法**：

```txt
Input: 数列 a[1..n]
Output: 最大子段和 S

current_max = 0
global_max = 0

for i in 1 to n:
    current_max = max(a[i], current_max + a[i])
    global_max = max(global_max, current_max)
end for

return global_max
```


## 0/1背包问题

> 因为 0/1 背包问题的讲解网上已经汗牛充栋，所以这里只做最简要的解题分析。
{: .prompt-tip }


> **问题描述**：你面前有 n 件物品，每件物品都有两个属性：重量 w 和价值 v。现在你有一个背包，它能承受的最大重量为 W。你需要在这些物品中做出选择，将其中一部分装入背包，使得背包内物品的总价值最大，同时总重量不能超过背包的容量 W。

这个问题的核心约束在于“**0/1**”特性：对于每一件物品，你只有两种选择——**要么不放进背包（0），要么完整地放进背包（1）**。你不能只放物品的一部分。

直觉上可能会考虑贪心策略，比如：

  * **价值优先**：每次选择价值最高的物品。  
  * **重量优先**：每次选择重量最轻的物品。  
  * **性价比优先**：每次选择价值/重量比最高的物品。

然而，这些贪心策略都可能失败，因为它们无法预见选择某件物品可能给其他组合留出更优空间。因此需要一个能考虑所有组合的全局最优算法。

### 1. 定义状态 (State)

> $F(i, j)$：表示在背包容量为 $j$ 的前提下，只从前 $i$ 件物品中进行选择，所能获得的最大总价值。  

最终目标是 $F(n, W)$，即从所有 $n$ 件物品中选择，在容量为 $W$ 的背包里能获得的最大价值。

### 2. 状态转移方程 (Recurrence Relation)
站在第 i 件物品的门前，我们有两个决策：
  * **不放第 i 件物品**  
    直接沿用前 i-1 件物品在容量 j 下的最优解：
$$
F(i, j) = F(i-1, j)
$$
  * **放第 i 件物品**  
    前提是背包能容纳，即 $j \ge w_i$。  
    此时获得价值 $v_i$，背包剩余容量为 $j - w_i$，由前 i-1 件物品填充：
$$
F(i, j) = v_i + F(i-1, j - w_i)
$$
选择两者中较大的值，得到状态转移方程：
$$
F(i, j) = \max\big(F(i-1, j), \; v_i + F(i-1, j - w_i)\big), \quad j \ge w_i
$$

### 3. 初始化 (Initialization)
  * $F(0, j) = 0$ 对所有 $j$：没有物品时，最大价值为 0。  
  * $F(i, 0) = 0$ 对所有 $i$：背包容量为 0 时，最大价值为 0。


> 以上三个步骤也是我的算法老师要求我们的答题规范步骤。
{: .prompt-tip }


### 空间优化

观察状态转移方程，我们发现计算第 $i$ 行的值，完全只依赖于第 $i-1$ 行的值。这意味着可以将二维 dp 表格压缩成一维，这个技巧称为**滚动数组**。

我们可以只用一个一维数组 `dp[j]`，它表示在处理了若干物品后，容量为 `j` 时的最大价值。
新的状态转移方程变为：
$$
\text{dp}[j] = \max(\text{dp}[j],\; v_i + \text{dp}[j - w_i])
$$
为了确保 `dp[j - w[i]]` 的值来自于上一轮（即处理第 `i-1` 件物品时）的计算结果，**内层对容量 `j` 的循环必须是倒序的**（从 `W` 减到 `w[i]`）。如果正序循环，我们用到的 `dp[j - w[i]]` 可能已经是被第 `i` 件物品更新过的值了，这就相当于把第 `i` 件物品放了多次，问题就从0/1背包变成了完全背包。

## 矩阵链乘法

> **问题描述**：给定一个由 $n$个矩阵组成的链 $A_{1},\cdots,A_{n}$，其中矩阵 $A_{i}$ 的维度为 $p_{i-1} \times p_{i}$。找出一种为这个乘积链完全加括号（即决定运算顺序）的方式，使得总的标量乘法次数最少.

这个问题的核心在于，无论最终的括号方案多么复杂，它的最后一次矩阵乘法总是由$S = (A_{1}\dots A_{k})$和$T = (A_{k+1}\dots A_{n})$这两组矩阵乘积的结果矩阵相乘。

而这一操作的代价是产生$S$的代价与产生$T$的代价与$ST$相乘的代价$p_{0} \cdot p_{k} \cdot p_{n}$的和。

定义状态$F(i,j)$表示$A_{i}\cdots A_{j}$相乘所需要的最少标量乘法次数，则存在$k \in [i,j)$使得

$$
F(i,j) = \min_{i\leq k<j}\{F(i,k) + F(k+1,j) + p_{i-1} \cdot p_{k} \cdot p_{j}\}
$$
因为单个矩阵不需要任何乘法，初始化$F(i,i) = 0, i \in[0,n]$.

我们必须先计算短链的代价，再计算长链的代价。因此，这个表格应该按这样的顺序填写计算
$$
F(1,1)\to F(2,2)\to\dots\to F(n,n)\to F(1,2)\to F(2,3)\to\dots\to F(n-1,n)\to\dots\to F(1,n)
$$
$F(1,n)$就是我们想要的结果。

每次计算分割点时记录算得的$k$，可以用来恢复最优结果的括号次序。


## LCS、SCS与编辑距离

### 最长公共子序列 (LCS)

> **问题描述**：给定两个序列 X 和 Y，找出一个在两个序列中都出现过的、长度最长的子序列。这个子序列被称为最长公共子序列 (Longest Common Subsequence)。

例如，对于序列 `X = president` 和 `Y = providence`，它们的LCS是 `priden` 。LCS可以用于评估两个序列的相似度。

我们定义状态 $F(i, j)$ 为序列 $X$ 的前 $i$ 个字符（即 $X[1 \dots i]$）与序列 $Y$ 的前 $j$ 个字符（即 $Y[1 \dots j]$）的LCS长度。我们的目标是求解 $F(m, n)$，其中 $m$ 和 $n$ 分别是 $X$ 和 $Y$ 的总长度。

在计算 $F(i, j)$ 时，我们主要关注两个序列的末尾字符 $X[i]$ 和 $Y[j]$：

* **情况一：$X[i] = Y[j]$**
    如果两个末尾字符相同，那么这个字符必然可以作为 $X[1 \dots i]$ 和 $Y[1 \dots j]$ 的LCS的最后一个字符。因此，问题就转化为寻找 $X[1 \dots i-1]$ 和 $Y[1 \dots j-1]$ 的LCS，然后在其长度上加 1。

* **情况二：$X[i] \neq Y[j]$**
    如果两个末尾字符不同，那么它们不可能同时出现在LCS的末尾。此时，LCS或者是 $X[1 \dots i-1]$ 和 $Y[1 \dots j]$ 的LCS，或者就是 $X[1 \dots i]$ 和 $Y[1 \dots j-1]$ 的LCS。我们取这两种可能中较长的那一个。

基于以上分析，我们得到状态转移方程：
$$
F(i, j) =
\begin{cases}
0 & \text{if } i=0 \text{ or } j=0 \\
F(i-1, j-1) + 1 & \text{if } X[i] = Y[j] \\
\max(F(i-1, j), F(i, j-1)) & \text{if } X[i] \neq Y[j]
\end{cases}
$$

该算法的时间和空间复杂度均为 $O(mn)$。

### 最短公共超序列 (SCS)

> **问题描述**：给定两个序列 X 和 Y，找出一个最短的序列 Z，使得 X 和 Y 同时都是 Z 的子序列。Z 被称为最短公共超序列 (Shortest Common Supersequence)。

例如，若 `X = abc`，`Y = abb`，则 `abcb` 和 `abbc` 都是它们的SCS。

同样，我们定义状态 $F(i, j)$ 为序列 $X[1 \dots i]$ 和 $Y[1 \dots j]$ 的SCS的长度。

* **情况一：$X[i] = Y[j]$**
    如果末尾字符相同，我们可以将这个公共字符作为超序列的一部分，从而同时满足 $X$ 和 $Y$ 的要求。问题因此简化为求解 $X[1 \dots i-1]$ 和 $Y[1 \dots j-1]$ 的SCS，然后在其长度上加 1。

* **情况二：$X[i] \neq Y[j]$**
    如果末尾字符不同，我们必须将 $X[i]$ 和 $Y[j]$ 都包含进超序列。此时有两种选择：要么先构造 $X[1 \dots i-1]$ 和 $Y[1 \dots j]$ 的SCS，然后追加 $X[i]$；要么先构造 $X[1 \dots i]$ 和 $Y[1 \dots j-1]$ 的SCS，然后追加 $Y[j]$。我们选择能产生更短结果的方案。

状态转移方程如下：
$$
F(i, j) =
\begin{cases}
j & \text{if } i=0 \\
i & \text{if } j=0 \\
F(i-1, j-1) + 1 & \text{if } X[i] = Y[j] \\
\min(F(i-1, j), F(i, j-1)) + 1 & \text{if } X[i] \neq Y[j]
\end{cases}
$$

> **SCS与LCS的关系**
> SCS的长度与LCS的长度有一个非常优美的关系：对于长度分别为 $m$ 和 $n$ 的序列 $X$ 和 $Y$，其LCS长度为 $L$，SCS长度为 $K$，则满足：
> $$L + K = m + n$$
> 这个关系可以这样理解：要构造SCS，我们可以先将两个序列的所有字符都放进去（总长 $m+n$），但这样公共部分（LCS）就被计算了两次，所以减去一次LCS的长度即可。
{: .prompt-tip }

### 编辑距离 (Edit Distance)

> **问题描述**：给定两个序列 $S_1$ 和 $S_2$，计算将 $S_1$ 转换成 $S_2$ 所需的最少单字符编辑操作次数。基本操作包括：插入一个字符、删除一个字符、替换一个字符。这个最少操作次数就是所谓的 **Levenshtein 距离**。

编辑距离广泛应用于拼写检查、生物信息学等领域。

定义状态 $F(i, j)$ 为将 $S_1$ 的前 $i$ 个字符转换成 $S_2$ 的前 $j$ 个字符所需的最小编辑距离。

为了计算 $F(i, j)$，我们考虑如何通过一次操作从一个已知的子问题状态转移而来：

1.  **删除**：我们可以先将 $S_1[1 \dots i-1]$ 转换成 $S_2[1 \dots j]$（这需要 $F(i-1, j)$ 次操作），然后删除 $S_1[i]$（1次操作）。总代价为 $F(i-1, j) + 1$。
2.  **插入**：我们可以先将 $S_1[1 \dots i]$ 转换成 $S_2[1 \dots j-1]$（这需要 $F(i, j-1)$ 次操作），然后插入 $S_2[j]$（1次操作）。总代价为 $F(i, j-1) + 1$。
3.  **替换/匹配**：我们可以将 $S_1[1 \dots i-1]$ 转换成 $S_2[1 \dots j-1]$（这需要 $F(i-1, j-1)$ 次操作），然后处理 $S_1[i]$ 和 $S_2[j]$。
    * 如果 $S_1[i] = S_2[j]$，则无需额外操作，总代价为 $F(i-1, j-1)$。
    * 如果 $S_1[i] \neq S_2[j]$，则需要一次替换操作，总代价为 $F(i-1, j-1) + 1$。

$F(i, j)$ 的值就是这三种可能路径中的最小代价。

状态转移方程为：
$$
F(i, j) =
\begin{cases}
j & \text{if } i=0 \\
i & \text{if } j=0 \\
\min \begin{cases} F(i-1, j) + 1 \\ F(i, j-1) + 1 \\ F(i-1, j-1) + \text{cost}(S_1[i], S_2[j]) \end{cases} & \text{if } i,j > 0
\end{cases}
$$
其中，$\text{cost}(a, b)$ 在 $a=b$ 时为 0，在 $a \neq b$ 时为 1。

## 最优二叉查找(Optimal BST)

> **问题描述**：给定$n$个已排序的键值$k_{1},\dots,k_{n}$，以及每个键值$k_{i}$被访问的概率$p_{i}$。
> 假设$k_{1} < k_{2} < \dots<k_{n}$,
> $\sum_{i=1}^np_{i} = 1$.
> 应该如何构建二叉查找树以最小化其成功查找的期望比较次数？

这个问题不同于Huffman编码，查找树的中序次序是固定的，并不只依赖频率。但显然具有更大访问概率的键值的顶点应该更接近于根。但是否可以直接作为根呢？这是行不通的，在最终构造出的BST里，若键值$k_{i}$的路径长度为$s_{i}$（即这个键值所在节点位于树的第$s_{i}$层）,总花销为$\sum_{i=1}^np_{i}s_{i}$.从这个式子出发，很容易举出反例。

> **二叉查找树BST**的性质是：任何节点的键值都大于其左子树中所有节点的键值，并小于其右子树中所有节点的键值 。
{: .prompt-tip }

这个问题的最优子结构与矩阵链乘法相似。记$T(i,j)$表示对应于键值$k_{i},\dots,k_{j}$的最优二叉查找树，并记$C(i,j)$表示成功查找的期望比较次数。

初始化$i>j$时，$T(i,j)$为空树，$C(i,j) = 0$.

$T(i,j)$必然会选择其中一个键$k_{s},i\leq s\leq j$作为根节点。而这棵树的左子树，必然是包含键值$k_{i},\dots,k_{s-1}$的最优BST；其右子树也必然是包含$k_{s+1},\dots,k_{j}$的最优BST。假设现在选出的$k_{s}$就是最优的，此时计算花销

$$
C(i,j) = p_{s}\times 1 + (C(i,s-1) + (p_{i}+\dots+p_{s-1})\times 1) + (C(s+1,j) + (p_{s+1}+\dots+p_{j})\times 1)
$$

括号里多出来的若干和项来自于树的增高。因为通过根节点$k_{s}$把左子树$T(i,s-1)$和$T(s+1,j)$连接起来，使得这两个树中所有节点的道路长度都增加了$1$. 整理公式得到状态转移方程

$$
C(i,j) = \left(\sum_{l=i}^{j} p_l\right) + \min_{i \le s \le j} \{ C(i,s-1) + C(s+1,j) \}
$$

> 当$i = s$时，看似会出现很奇怪的$C(i,i-1)$, 但因为初始化过空树所以不用担心。
{: .prompt-tip }


求和开销很大，为了降低时间复杂度，通常引入前缀和$S(k) = \sum_{i=1}^kp_{i}$, 则

$$
C(i,j) = S(j)-S(i-1) + \min_{i \le s \le j} \{ C(i,s-1) + C(s+1,j) \}
$$

## 总结

一个问题适合用动态规划求解，通常具备两个要素：**最优子结构**和**重叠子问题** 。

1.  **最优子结构 (Optimal Substructure)**
    这是DP的基石。它指的是一个问题的最优解，包含了其子问题的最优解 。无论是矩阵链乘法中“子链的相乘方式也必须最优”，还是LCS中“子序列的前缀也必须是LCS”，都体现了这一特性。
    值得注意的是，并非所有问题都满足此特性，这样的问题也不能使用动态规划方法解决。

2.  **重叠子问题 (Overlapping Subproblems)**
    这是DP效率的来源。在纯递归的解法中，许多相同的子问题会被反复计算。DP通过“记忆化（自顶向下）”或“制表（自底向上）”的方式，确保每个子问题只被计算一次，从而将指数级的时间复杂度降低到多项式级别 。

动态规划问题的编码总是简单的，难点在于找出那个递推公式

$$
P(\mathrm{X}) = \phi(f(P(\mathrm{X-A_{1}}),\dots,P(\mathrm{X-A_{d}})))
$$

通常$\phi \to \min / max$.

总结下来，我们接触到的问题可以大致归为几类常见的DP模型：

1.  **线性DP**：状态通常是一维的 `dp[i]`，依赖于 `i` 之前的状态。
    * *例子*: 找零钱问题、最长递增子序列(LIS)、最大子段和。

2.  **二维/背包DP**：状态是二维的 `dp[i][j]`，通常涉及两个变化的维度，如物品种类和容量，或两个序列的长度。
    * *例子*: 0/1背包问题、最长公共子序列、编辑距离。

3.  **区间DP**：状态 `dp[i][j]` 代表区间 `[i, j]` 上的最优解，该解由更小的子区间的解组合而成。
    * *例子*: 矩阵链乘法、最优二叉查找树。

作为一种填表方法，自己尝试填一填是很重要的！