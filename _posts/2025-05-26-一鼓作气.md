---
title: 一鼓作气
author: 凉香栾
date: 2025-05-26 19:03:21 +0800
categories:
  - 算法题解
tags:
  - 动态规划
description: 动态规划系列参考题解四
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath:
---


## 题目描述

BAT国为了防御CAT国，训练了一支攻无不克的奇袭队。但是虽然奇袭队的第一次冲锋能够到达任意远的距离，但是以后每一次冲锋都无法远于前一次的距离。  
这一天，BAT国获悉CAT国先后派出多支队伍驻扎在不同的距离；而目前只有一支奇袭队，因此有可能无法攻破所有的驻地。  
  
> **输入：**  
> CAT国派来的队伍总数$n(\le 12000)$ ；  
> 多支队伍依次驻扎的不同距离$a_{i} \le 99999999$。  
> **输出：**  
> 计算这时的这支奇袭队最多能先后攻破多少驻地。  
> 如果要攻破所有驻地最少要多少支这样的奇袭队？

## 解题思路

首先，我们需要正确理解题目中“冲锋距离”的规则。规则是“以后每一次冲锋都无法远于前一次的距离”。
如果我们攻击的驻地序列是 `a[i], a[j], a[k], ...` (其中 `i < j < k < ...`)，最直接的理解是每次冲锋的**位移**不能超过上一次，即 `a[j]-a[i] <= a[i]`，`a[k]-a[j] <= a[j]-a[i]` 等。这种解释会让问题变得异常复杂。

结合AC代码的逻辑，我们可以发现题目有一个更简洁的解释：这里的“冲锋距离”指的是驻地的**绝对坐标**。
* “第一次冲锋能够到达任意远的距离”：奇袭队可以任选一个驻地作为第一个攻击目标。
* “以后每一次冲锋都无法远于前一次的距离”：如果上一个攻击的驻地坐标是 `D_prev`，那么下一个攻击的驻地坐标 `D_next` 必须满足 `D_next <= D_prev`。

在这个解释下，问题就清晰了：

1.  **第一问**：一支奇袭队最多能攻破多少驻地？
    这等价于：在给定的序列 `a` 中，找到一个**子序列**，这个子序列是**非增**的（即 `a[i] >= a[j] >= a[k]...`），并求这个子序列的最大可能长度。这就是经典的 **最长非增子序列 (Longest Non-Increasing Subsequence, LNIS)** 问题。

2.  **第二问**：如果要攻破所有驻地最少要多少支奇袭队？
    每支奇袭队可以负责一条非增子序列。要把所有驻地（整个序列）都覆盖到，就需要将原序列 `a` **划分**成若干个非增子序列。问题就是求这个划分所需的最少子序列数。
    根据著名的 **Dilworth定理**，**一个序列的最小非增子序列划分数，等于其最长递增子序列的长度**。
    因此，第二问等价于求序列 `a` 的 **最长递增子序列 (Longest Increasing Subsequence, LIS)** 的长度。

### 第一问求解：最长非增子序列 (LNIS)

这是一个标准的动态规划问题。

* **状态定义**: `dp[i]` 表示以 `a[i]` 这个元素**结尾**的最长非增子序列的长度。

* **状态转移方程**:
    为了计算 `dp[i]`，我们需要考察所有在 `i` 之前的位置 `j` (`0 <= j < i`)。
    如果 `a[j] >= a[i]`，说明 `a[i]` 可以接在以 `a[j]` 结尾的非增子序列后面，形成一个更长的序列。
    因此，`dp[i]` 的值，是在所有满足 `a[j] >= a[i]` 的 `dp[j]` 中取最大值，然后加1。
    $$dp[i] = 1 + \max(\{dp[j] \mid 0 \le j < i \text{ and } a_j \ge a_i\} \cup \{0\})$$
    （ `max` 中加入 `0` 是为了处理 `a[i]` 作为序列开头的情况）

* **最终答案**: 整个序列的LNIS长度，是所有 `dp[i]` 值中的最大值。

AC代码中的第一部分就是该算法的 $O(n^2)$ 实现。

### 第二问求解：最长递增子序列 (LIS)

求解LIS有多种方法，AC代码中使用的是一种贪心思想的优化DP。

* **算法思想**:
    我们维护一个数组 `t`，其中 `t[k]` 存放的是所有长度为 `k+1` 的递增子序列中，结尾元素最小的那个值。这个 `t` 数组一定是单调递增的。

* **算法流程**:
    遍历原序列 `a` 的每一个元素 `a[i]`：
    1.  在 `t` 数组中，查找第一个**不小于** `a[i]` 的元素 `t[j]`。 (AC代码中用了一个线性查找，这里可以用二分查找优化到 $O(\log n)$)
    2.  **如果找到了**这样的 `t[j]`，就用 `a[i]` 替换它 (`t[j] = a[i]`)。
        * 这步的意义是：我们找到了一个长度为 `j+1` 的递增子序列，它的结尾比之前记录的更小(`a[i]`)，这为后续元素接到它后面提供了更好的条件。
    3.  **如果没找到**（说明 `a[i]` 比 `t` 中所有元素都大），就将 `a[i]` 追加到 `t` 数组的末尾。
        * 这步的意义是：`a[i]` 可以接在已知的最长递增子序列后面，形成一个更长的递增子序列。

* **最终答案**: 遍历结束后，`t` 数组的长度 `p`，就是原序列 `a` 的最长递增子序列的长度。


## 附AC代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

#define ll long long

ll n,a[12010],dp[12010],t[12010];

int main(){
    cin >> n;

    for (ll i = 0; i < n; ++i)
        cin >> a[i];

    ll ans1 = 1;
    for (ll i = 0; i < n; ++i) {
        dp[i] = 1;
        for (ll j = 0; j < i; ++j) {
            if (a[j] >= a[i]) {
                if (dp[j] + 1 > dp[i])
                    dp[i] = dp[j] + 1;
            }
        }
        if (dp[i] > ans1)
            ans1 = dp[i];
    }

    ll p = 0;
    for (ll i = 0; i < n; ++i) {
        ll pos = -1;
        for (ll j = 0; j < p; ++j) {
            if (t[j] >= a[i]) {
                pos = j;
                break;
            }
        }
        if (pos == -1) 
            t[p++] = a[i];
        else 
            t[pos] = a[i];
        
    }

    cout <<  ans1 << "\n" << p << endl;

    return 0;
}


```