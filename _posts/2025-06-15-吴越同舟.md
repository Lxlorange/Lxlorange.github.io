---
title: 吴越同舟
author: 凉香栾
date: 2025-06-15 22:31:47 +0800
categories:
  - 算法题解
tags:
  - 分支限界
description: 分支限界系列参考题解三
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath:
---


## 题目描述

春秋时期，吴国和越国是宿敌。现在，需要从 `n` 个人中选出一个代表团，去参加诸侯间的重要会议。然而，这 `n` 个人中，有些来自吴国，有些来自越国，彼此之间存在着 `m` 对冲突关系。如果两个人之间存在冲突，他们就不能同时出现在代表团中。

为了在会议上获得最大的话语权，需要派出的代表团人数尽可能多。请计算在满足“代表团内任何人之间都没有冲突”这一前提下，能派出的最大代表团人数。


> **输入：**
> 第一行是两个整数 `n` 和 `m`，分别代表总人数和冲突关系的数量。
> 接下来 `m` 行，每行两个整数 `u` 和 `v`，表示 `u` 和 `v` 之间存在冲突。     
>  **输出：**
 > 一个整数，表示最大可能代表团的人数。


## 解题思路

这实际上是一个求最大团的问题。将 `n` 个人中的每一个人看作图的一个顶点，如果两个人之间没有冲突关系（即他们是兼容的），就在他们对应的顶点之间连一条边，我们需要在这样构成的图中找到最大团。对于这个问题，我们有个经典板子能套，即**Bron-Kerbosch算法**。

BK算法在搜索过程中，维护三个集合：
- **R**: 当前正在构建的团中的顶点集合。
- **P**: **候选集**。P中的所有顶点都与R中的所有顶点相连，是用于扩展R的候选顶点。
- **X**: **已处理集**。X中的顶点也与R中所有顶点相連，但它们已经被其他分支处理过。设置X是为了防止重复生成同一个团，并避免死循环。

算法的基本流程是：从P中依次选择一个顶点`v`，将其加入R，并以`v`的邻居更新P和X，然后进行递归。

同时我们可以在搜索过程中剪枝。如果当前团的大小 `rsize` 加上所有剩余候选者 `|P|` 的数量，仍然不能超过已经找到的最优解 `ans`，那么这条搜索路径就没有必要再继续下去了。即为估界函数：
$$
rsize + \|P\| \le ans
$$
BK算法本身还提供了一种剪枝策略。正常搜索中，我们需要对P中的每个顶点都进行一次递归。但对于任意一个极大团，它要么包含轴心点 `u`，要么包含 `u` 的某个非邻居。因此，我们只需要对轴心 `u` 的**非邻居**进行递归分支即可，因为包含 `u` 的邻居的那些团，会在其他分支中被找到。

从 `P ∪ X` 中选择**轴心点 (pivot)** `u`时，为了达到最好的剪枝效果，我们选择在 `P` 中邻居最多的那个点作为轴心 `u`。因为这样一来，`u` 在 `P` 中的非邻居数量 `|P \ N(u)|` 就会最少，意味着需要递归的次数也最少，从遍历整个集合 `P`，优化为只遍历 `P \ N(u)` 这个更小的集合。这极大地减少了搜索树的宽度。


## 附AC代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 160;
int n, m, ans;
bool g[N][N], compg[N][N];

int P_[N+1][N], X_[N+1][N], ps[N+1], xs[N+1];

void BK(int dep, int rsize) {
    if (rsize + ps[dep] <= ans) return;

    if (ps[dep] == 0 && xs[dep] == 0) {
        ans = max(ans, rsize);
        return;
    }

    int U[N], usz = 0;
    for (int i = 0; i < ps[dep]; i++) U[usz++] = P_[dep][i];
    for (int i = 0; i < xs[dep]; i++) U[usz++] = X_[dep][i];

    int pivot = -1, best = -1;
    for (int i = 0; i < usz; i++) {
        int u = U[i], cnt = 0;
        for (int j = 0; j < ps[dep]; j++)
            if (compg[u][ P_[dep][j] ]) cnt++;
        if (cnt > best) { best = cnt; pivot = u; }
    }

    int C[N], cz = 0;
    for (int i = 0; i < ps[dep]; i++) {
        int v = P_[dep][i];
        if (pivot < 0 || !compg[pivot][v])
            C[cz++] = v;
    }

    for (int i = 0; i < cz; i++) {
        int v = C[i];

        int oldPs = ps[dep], oldXs = xs[dep];
        int Pcopy[N], Xcopy[N];
        memcpy(Pcopy, P_[dep], oldPs * sizeof(int));
        memcpy(Xcopy, X_[dep], oldXs * sizeof(int));

        for (int j = 0; j < ps[dep]; j++) {
            if (P_[dep][j] == v) {
                P_[dep][j] = P_[dep][--ps[dep]];
                break;
            }
        }
        X_[dep][ xs[dep]++ ] = v;

        int p2 = 0, x2 = 0;
        for (int j = 0; j < oldPs; j++) {
            int w = Pcopy[j];
            if (compg[v][w]) P_[dep+1][p2++] = w;
        }
        for (int j = 0; j < oldXs; j++) {
            int w = Xcopy[j];
            if (compg[v][w]) X_[dep+1][x2++] = w;
        }
        ps[dep+1] = p2;
        xs[dep+1] = x2;

        BK(dep+1, rsize+1);

        ps[dep] = oldPs;
        xs[dep] = oldXs;
        memcpy(P_[dep], Pcopy, oldPs * sizeof(int));
        memcpy(X_[dep], Xcopy, oldXs * sizeof(int));
    }
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=0,u,v;i<m;i++){
        scanf("%d%d",&u,&v);
        --u;--v;
        g[u][v] = g[v][u] = 1;
    }
    for(int i=0;i<n;i++)for(int j=0;j<n;j++)
            compg[i][j] = (i!=j && !g[i][j]);

    for(int i=0;i<n;i++) P_[0][i] = i;
    ps[0] = n;
    xs[0] = 0;
    ans = 0;

    BK(0, 0);
    printf("%d\n", ans);
    return 0;
}


```