---
title: 分金子
author: 凉香栾
date: 2025-06-15 22:38:53 +0800
categories:
  - 算法题解
tags:
  - 分支限界
description: 分支限界系列参考题解二
toc: true
pin: false
math: true
mermaid: true
comment: true
media_subpath:
---


## 题目描述

在一个 `n x m` 的矩形网格金矿中，我们需要放置若干个“矿工”。在任意一个格子 `(i, j)` 上放置一个矿工，可以开采到该格子以及其上、下、左、右四个相邻格子（共5个格子）的金子。

**目标**：计算要开采所有格子的金子（即覆盖整个网格），最少需要放置多少个矿工。

>  **输入**：一行，两个整数 `n` 和 `m`，代表金矿的行数和列数。
>  **输出**：一个整数，表示覆盖整个网格所需的最少矿工数量。


## 解题思路

这是一个集合覆盖问题，属于的NP-hard问题。对于每个格子，我们都有“放”或“不放”矿工两种选择，总的解空间高达 $2^{n \times m}$。需要在DFS的基础上增加高效的剪枝条件。

**剪枝1：至少还需要的矿工数量**

假设未来我们放置的每一个矿工都能发挥最大效用。一个矿工最多能覆盖5个**未被覆盖**的格子。设当前还有 `uncov` 个格子未被覆盖。那么，最理想的情况下，我们还需要放置的矿工数量至少为 $\lceil \frac{\text{uncov}}{5} \rceil$。在整数运算中，这等价于 `(uncov + 4) / 5`。

可得**估界函数**：
$$\text{count} + (\text{uncov} + 4) / 5 \ge \text{ans}$$
如果当前已放置的矿工数，加上未来最少还需要的矿工数，已经不小于当前找到的最优解 `ans`，则可以直接剪枝。

**剪枝2：无法覆盖格子的情况**

因为会按照从上到下、从左到右的顺序遍历格子，当我们搜索到第 `i` 行时，我们已经做完了所有在 `i-1` 行及更早行上放置矿工的决策。此时，第 `i-2` 行的格子状态已经**最终确定**，因为它不可能再被之后（第 `i` 行或更晚）放置的矿工所覆盖。如果第 `i-2` 行仍有未覆盖的格子，说明之前的决策已导致了一个无解的局面。无论后续如何操作，都不可能再覆盖到第 `i-2` 行了。因此，这是一个死局，必须立即剪枝。

**剪枝3：决策剪枝**

当我们按顺序搜索到格子 `(i, j)` 时，考虑它正上方的格子 `(i-1, j)`。如果 `(i-1, j)` 此刻仍未被覆盖，那么能够覆盖它的机会只剩下一次：**在 `(i, j)` 放置一个矿工**。因为我们之后的搜索将去往 `(i, j+1)` 或第 `i+1` 行，这些位置都无法再覆盖到 `(i-1, j)`。

如果 `(i-1, j)` 未被覆盖，则我们**必须**在 `(i, j)` 放置一个矿工。此时就不存在“不放”这个选项了，搜索树的分支被剪掉了一半。这极大地压缩了搜索空间。

综合以上剪枝，可以高效地AC题目。

## 附AC代码

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

int n, m, ans;
bool placed[15][15];
int coverCnt[15][15];
int uncov;
int maxPossible;

const int dx[5] = {0, 1, -1, 0, 0};
const int dy[5] = {0, 0, 0, 1, -1};

inline bool in(int x, int y) {
    return x >= 0 && x < n && y >= 0 && y < m;
}

void putOne(int i, int j) {
    placed[i][j] = true;
    for (int k = 0; k < 5; ++k) {
        int x = i + dx[k], y = j + dy[k];
        if (in(x, y)) {
            if (coverCnt[x][y] == 0) uncov--;
            coverCnt[x][y]++;
        }
    }
}

void removeOne(int i, int j) {
    placed[i][j] = false;
    for (int k = 0; k < 5; ++k) {
        int x = i + dx[k], y = j + dy[k];
        if (in(x, y)) {
            coverCnt[x][y]--;
            if (coverCnt[x][y] == 0) uncov++;
        }
    }
}

inline bool checkRowCovered(int row) {
    for (int k = 0; k < m; ++k)
        if (coverCnt[row][k] == 0) return false;
    return true;
}

inline bool checkRowUncovered(int row) {
    for (int k = 0; k < m; ++k)
        if (coverCnt[row][k] == 0) return true;
    return false;
}

void dfs(int i, int j, int count) {
    if (count + (uncov + 4) / 5 >= ans) return;
    
    if (i >= 2 && checkRowUncovered(i - 2)) return;
    
    if (i == n) {
        if (uncov == 0) ans = min(ans, count);
        return;
    }
    
    if (j == m) {
        if (i >= 1 && checkRowUncovered(i - 1)) return;
        dfs(i + 1, 0, count);
        return;
    }
    
    if (coverCnt[i][j] > 0) {
        if (i >= 1 && coverCnt[i-1][j] == 0) {
            putOne(i, j);
            dfs(i, j + 1, count + 1);
            removeOne(i, j);
        } else {
            dfs(i, j + 1, count);
        }
        return;
    }
    
    if (i >= 1 && coverCnt[i - 1][j] == 0) {
        putOne(i, j);
        dfs(i, j + 1, count + 1);
        removeOne(i, j);
        return;
    }
    
    dfs(i, j + 1, count);
    
    putOne(i, j);
    dfs(i, j + 1, count + 1);
    removeOne(i, j);
}

int main() {
    scanf("%d%d", &n, &m);
    
    ans = n * m;
    maxPossible = n * m;

    
    uncov = n * m;
    dfs(0, 0, 0);
    printf("%d\n", ans);
    return 0;
}

```